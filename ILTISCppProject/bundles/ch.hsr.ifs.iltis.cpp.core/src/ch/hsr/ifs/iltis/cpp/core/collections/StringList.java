package ch.hsr.ifs.iltis.cpp.core.collections;

import java.util.Arrays;
import java.util.Collection;
import java.util.StringTokenizer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.eclipse.collections.api.block.function.Function0;
import org.eclipse.collections.impl.list.mutable.AbstractMutableList;
import org.eclipse.collections.impl.list.mutable.FastList;

import ch.hsr.ifs.iltis.cpp.core.resources.info.IStringifyable;
import ch.hsr.ifs.iltis.cpp.core.resources.info.annotations.InfoArgument;


/**
 * String-List that is stringifyable. Can be used as an {@link InfoArgument}.
 *
 * @author tstauber
 * 
 * @since 1.1
 *
 */
public class StringList extends AbstractMutableList<String> implements IStringifyable<StringList> {

    private static final String[] DEFAULT_SIZED_EMPTY_ARRAY = {};
    private static final String[] ZERO_SIZED_ARRAY          = {};
    private static final int      MAXIMUM_ARRAY_SIZE        = Integer.MAX_VALUE - 8;

    protected final String LIST_SEPARATOR = IStringifyable.LIST_SEPARATOR;

    protected int                size;
    protected transient String[] items = DEFAULT_SIZED_EMPTY_ARRAY;

    public StringList() {}

    public StringList(final int initialCapacity) {
        items = initialCapacity == 0 ? ZERO_SIZED_ARRAY : new String[initialCapacity];
    }

    protected StringList(final String[] array) {
        this(array.length, array);
    }

    protected StringList(final int size, final String[] array) {
        this.size = size;
        items = array;
    }

    public StringList(final Collection<String> source) {
        items = (String[]) source.toArray();
        size = items.length;
    }

    public static StringList newList() {
        return new StringList();
    }

    public static StringList wrapCopy(final String... array) {
        final String[] newArray = new String[array.length];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return new StringList(newArray);
    }

    public static StringList newList(final int initialCapacity) {
        return new StringList(initialCapacity);
    }

    /**
     * Creates a new list using the passed {@code elements} argument as the backing store.
     * <p>
     * !!! WARNING: This method uses the passed in array, so can be very unsafe if the original
     * array is held onto anywhere else. !!!
     */
    public static StringList newListWith(final String... elements) {
        return new StringList(elements);
    }

    /**
     * Creates a new FastList pre-sized to the specified size filled with default values generated by the specified function.
     *
     * @since 3.0
     */
    public static <E> FastList<E> newWithNValues(final int size, final Function0<E> factory) {
        final FastList<E> newFastList = FastList.newList(size);
        for (int i = 0; i < size; i++) {
            newFastList.add(factory.value());
        }
        return newFastList;
    }

    protected static String SEPARATOR = "{LS}";

    @Override
    public StringList unstringify(final String string) {
        final StringTokenizer tokenizer = new StringTokenizer(string, SEPARATOR);
        while (tokenizer.hasMoreTokens()) {
            add(tokenizer.nextToken());
        }
        return this;
    }

    @Override
    public String stringify() {
        return Stream.of(items).collect(Collectors.joining(SEPARATOR));
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public void clear() {
        Arrays.fill(items, 0, size, null);
        size = 0;
    }

    @Override
    public boolean addAll(final int index, final Collection<? extends String> source) {
        if (index > size || index < 0) {
            throwOutOfBounds(index);
        }
        if (source.isEmpty()) {
            return false;
        }

        final Object[] newItems = source.toArray();
        final int sourceSize = newItems.length;
        final int newSize = size + sourceSize;
        ensureCapacity(newSize);
        shiftElementsAtIndex(index, sourceSize);
        size = newSize;
        System.arraycopy(newItems, 0, items, index, sourceSize);

        return true;
    }

    private void shiftElementsAtIndex(final int index, final int sourceSize) {
        final int numberToMove = size - index;
        if (numberToMove > 0) {
            System.arraycopy(items, index, items, index + sourceSize, numberToMove);
        }
    }

    @Override
    public String get(final int index) {
        if (index < size) return items[index];
        throw new IndexOutOfBoundsException("Index: " + index + " Size: " + size);
    }

    @Override
    public String set(final int index, final String element) {
        final String previous = get(index);
        items[index] = element;
        return previous;
    }

    @Override
    public boolean add(final String newItem) {
        if (items.length == size) {
            ensureCapacityForAdd();
        }
        items[size++] = newItem;
        return true;
    }

    @Override
    public void add(final int index, final String element) {
        if (index > -1 && index < size) {
            addAtIndex(index, element);
        } else if (index == size) {
            this.add(element);
        } else {
            throwOutOfBounds(index);
        }
    }

    private void addAtIndex(final int index, final String element) {
        final int oldSize = size++;
        if (items.length == oldSize) {
            final String[] newItems = new String[sizePlusFiftyPercent(oldSize)];
            if (index > 0) {
                System.arraycopy(items, 0, newItems, 0, index);
            }
            System.arraycopy(items, index, newItems, index + 1, oldSize - index);
            items = newItems;
        } else {
            System.arraycopy(items, index, items, index + 1, oldSize - index);
        }
        items[index] = element;
    }

    private void ensureCapacityForAdd() {
        if (items == DEFAULT_SIZED_EMPTY_ARRAY) {
            items = new String[10];
        } else {
            transferItemsToNewArrayWithCapacity(sizePlusFiftyPercent(size));
        }
    }

    private void throwOutOfBounds(final int index) {
        throw new IndexOutOfBoundsException("Index: " + index + " Size: " + size);
    }

    public void ensureCapacity(final int minCapacity) {
        final int oldCapacity = items.length;
        if (minCapacity > oldCapacity) {
            final int newCapacity = Math.max(sizePlusFiftyPercent(oldCapacity), minCapacity);
            transferItemsToNewArrayWithCapacity(newCapacity);
        }
    }

    private void transferItemsToNewArrayWithCapacity(final int newCapacity) {
        items = copyItemsWithNewCapacity(newCapacity);
    }

    private String[] copyItemsWithNewCapacity(final int newCapacity) {
        final String[] newItems = new String[newCapacity];
        System.arraycopy(items, 0, newItems, 0, Math.min(size, newCapacity));
        return newItems;
    }

    private int sizePlusFiftyPercent(final int oldSize) {
        final int result = oldSize + (oldSize >> 1) + 1;
        return result < oldSize ? MAXIMUM_ARRAY_SIZE : result;
    }

    @Override
    public String remove(final int index) {
        final String previous = get(index);
        final int totalOffset = size - index - 1;
        if (totalOffset > 0) {
            System.arraycopy(items, index + 1, items, index, totalOffset);
        }
        items[--size] = null;
        return previous;
    }

}
