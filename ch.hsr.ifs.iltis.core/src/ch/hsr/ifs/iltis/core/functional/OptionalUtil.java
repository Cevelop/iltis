package ch.hsr.ifs.iltis.core.functional;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

import ch.hsr.ifs.iltis.core.functional.functions.ThrowingConsumer;
import ch.hsr.ifs.iltis.core.functional.functions.ThrowingFunction;
import ch.hsr.ifs.iltis.core.functional.functions.ThrowingSupplier;


/**
 * A utility class which provides static methods for operations on {@linkplain Optional} which exceed the possibilities implemented on Optional.
 * 
 * @author tstauber
 *
 */
public abstract class OptionalUtil {

   /**
    * Returns a value provided by the passed Supplier when the optional is not empty, else an empty Optional.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param fun
    *        The Supplier used to generate an Optional
    * @returns The Optional generated by fun if {@code optional} is not empty
    * @returns Else an empty Optional
    */
   public static <T, R> Optional<R> returnIfPresentElseEmpty(final Optional<T> optional, final Supplier<Optional<R>> fun) {
      return optional.isPresent() ? fun.get() : Optional.empty();
   }

   /**
    * Returns a value provided by the passed Function when the optional is not empty, else an empty Optional.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param fun
    *        The Function used to generate an Optional
    * @returns The Optional generated by fun if {@code optional} is not empty
    * @returns Else an empty Optional
    */
   public static <T, R> Optional<R> returnIfPresentElseEmpty(final Optional<T> optional, final Function<T, Optional<R>> fun) {
      return optional.isPresent() ? fun.apply(optional.get()) : Optional.empty();
   }

   /**
    * Returns a value provided by the passed Function when the optional is not empty, else {@code null}.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @returns An object of {@linkplain R} if {@code optional} is not empty
    * @returns Else {@code null}
    */
   public static <T, R> R returnIfPresentElseNull(final Optional<T> optional, final Function<T, R> funThen) {
      return optional.isPresent() ? funThen.apply(optional.get()) : null;
   }

   /**
    * Returns a value provided by the passed Functions depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Supplier which returns an {@linkplain R}
    * @param funElse
    *        A Supplier which returns an {@linkplain R}
    * @return An object of {@linkplain R}
    */
   public static <T, R> R returnIfPresentElse(final Optional<T> optional, final Supplier<R> funThen, final Supplier<R> funElse) {
      return optional.isPresent() ? funThen.get() : funElse.get();
   }

   /**
    * Returns a value provided by the passed Functions depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @param funElse
    *        A Supplier which returns an {@linkplain R}
    * @return An object of {@linkplain R}
    */
   public static <T, R> R returnIfPresentElse(final Optional<T> optional, final Function<T, R> funThen, final Supplier<R> funElse) {
      return optional.isPresent() ? funThen.apply(optional.get()) : funElse.get();
   }

   /**
    * Returns a value provided by either the passed Function or the default value depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @param valElse
    *        The value returned if the optional is empty
    * @return An object of {@linkplain R}
    */
   public static <T, R> R returnIfPresentElse(final Optional<T> optional, final Function<T, R> funThen, final R valElse) {
      return optional.isPresent() ? funThen.apply(optional.get()) : valElse;
   }

   /**
    * Returns a value provided by the passed Functions depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param <E>
    *        The exception type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which can throw and takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @param funElse
    *        A Supplier which returns an {@linkplain R}
    * @return An object of {@linkplain R}
    * @throws E
    *         pass-through from funThen
    */
   public static <T, R, E extends Exception> R returnIfPresentTElse(final Optional<T> optional, final ThrowingFunction<T, R, E> funThen,
            final Supplier<R> funElse) throws E {
      return optional.isPresent() ? funThen.apply(optional.get()) : funElse.get();
   }

   /**
    * Returns a value provided by the passed Functions depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param <E>
    *        The exception type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @param funElse
    *        A Supplier which can throw and returns an {@linkplain R}
    * @return An object of {@linkplain R}
    * @throws E
    *         pass-through from funElse
    */
   public static <T, R, E extends Exception> R returnIfPresentElseT(final Optional<T> optional, final Function<T, R> funThen,
            final ThrowingSupplier<R, E> funElse) throws E {
      return optional.isPresent() ? funThen.apply(optional.get()) : funElse.get();
   }

   /**
    * Returns a value provided by the passed Functions depending on the emptiness of the passed Optional
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <R>
    *        The return type
    * @param <E1>
    *        The funThen's exception type
    * @param <E2>
    *        The funElse's exception type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A Function which can throw and takes the extracted value of the passed Optional and returns an {@linkplain R}
    * @param funElse
    *        A Supplier which can throw and returns an {@linkplain R}
    * @return An object of {@linkplain R}
    * @throws E1
    *         pass-through from funThen
    * @throws E2
    *         pass-through from funElse
    */
   public static <T, R, E1 extends Exception, E2 extends Exception> R returnIfPresentTElseT(final Optional<T> optional,
            final ThrowingFunction<T, R, E1> funThen, final ThrowingSupplier<R, E2> funElse) throws E1, E2 {
      return optional.isPresent() ? funThen.apply(optional.get()) : funElse.get();
   }

   /**
    * Executes the passed function, if the optional has a value present.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A function which takes the extracted value of the passed Optional
    */
   public static <T> void doIfPresent(final Optional<T> optional, final Consumer<T> funThen) {
      if (optional.isPresent()) {
         funThen.accept(optional.get());
      }
   }

   /**
    * Executes the passed function, if the optional has a value present.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A function which takes the extracted value of the passed Optional
    * @param funElse
    *        A function which will be executed if the Optional has no value present
    */
   public static <T> void doIfPresentElse(final Optional<T> optional, final Consumer<T> funThen, final Runnable funElse) {
      if (optional.isPresent()) {
         funThen.accept(optional.get());
      } else {
         funElse.run();
      }
   }

   /**
    * Executes the passed function, if the optional has a value present.
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <E>
    *        The exception type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A function which can throw and takes the extracted value of the passed Optional
    * @throws E
    *         pass-through from funThen
    */
   public static <T, E extends Exception> void doIfPresentT(final Optional<T> optional, final ThrowingConsumer<T, E> funThen) throws E {
      if (optional.isPresent()) {
         funThen.accept(optional.get());
      }
   }

   /**
    * Executes one of the passed functions, depending on the optional holding a value
    * 
    * @param <T>
    *        The type wrapped by the Optional
    * @param <E>
    *        The exception type
    * @param optional
    *        The Optional to test
    * @param funThen
    *        A function which can throw and takes the extracted value of the passed Optional
    * @param funElse
    *        A function which will be executed if the Optional is empty
    */
   public static <T, E extends Exception> void doIfPresentTElse(final Optional<T> optional, final ThrowingConsumer<T, E> funThen,
            final Runnable funElse) throws E {
      if (optional.isPresent()) {
         funThen.accept(optional.get());
      } else {
         funElse.run();
      }
   }

}
